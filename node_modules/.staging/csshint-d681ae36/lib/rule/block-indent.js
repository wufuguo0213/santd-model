'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.check = undefined;

var _chalk = require('chalk');

var _chalk2 = _interopRequireDefault(_chalk);

var _postcss = require('postcss');

var _postcss2 = _interopRequireDefault(_postcss);

var _util = require('../util');

var _prefixes = require('../prefixes');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @file block-indent 的检测逻辑
 *       002: [强制] 使用 `4` 个空格做为一个缩进层级，不允许使用 `2` 个空格 或 `tab` 字符。
 * @author ielgnaw(wuji0223@gmail.com)
 */

'use strict';

var prefixList = (0, _prefixes.getPrefixList)();

/**
 * 当前文件所代表的规则名称
 *
 * @const
 * @type {string}
 */
var RULENAME = 'block-indent';

/**
 * 行号的缓存，防止同一行多次报错
 *
 * @type {number}
 */
var lineCache = 0;

/**
 * 获取错误信息
 *
 * @param {string} curIndentStr 当前的缩进的字符串（错误的）
 * @param {string} neededIndentStr 期望的的缩进的字符串（正确的）
 *
 * @return {string} 错误信息
 */
var getMsg = function getMsg(curIndentStr, neededIndentStr) {
    return '' + 'Bad indentation, Expected `' + neededIndentStr.length + '` but saw `' + curIndentStr.length + '`';
};

/**
 * 判断是否是合法的带前缀的 css 属性名称
 *
 * @param {Object} decl postcss 节点对象
 *
 * @return {boolean} 结果
 */
var isValidVendorProp = function isValidVendorProp(decl) {
    var prop = decl.prop;
    var standardProperty = prop.replace(/^\-(webkit|moz|ms|o)\-/g, '');
    // 标准模式在 prefixList 中，那么如果 propertyName 不在 prefixList 中
    // 即这个属性用错了，例如 -o-animation
    if (prefixList.indexOf(standardProperty) > -1) {
        if (prefixList.indexOf(prop) <= -1) {
            return false;
        }
    }
    return true;
};

/**
 * 对 decl 的处理
 *
 * @param {Object} node node 对象，可能是 decl 也可能是 rule
 * @param {Object} result postcss 转换的结果对象
 * @param {string} msg 错误信息
 * @param {string} hackPrefixChar 属性 hack 的前缀，`_` 或者 `*`
 */
var addWarn = function addWarn(node, result, msg, hackPrefixChar) {
    var source = node.source;
    var line = source.start.line;
    if (lineCache !== line) {
        lineCache = line;
        var col = source.start.column;

        var lineContent = (0, _util.getLineContent)(line, source.input.css) || '';
        var colorStr = '';

        if (node.selector) {
            colorStr = node.selector;
        } else if (node.type === 'atrule') {
            colorStr = lineContent;
        } else {
            colorStr = (hackPrefixChar || '') + node.prop + node.raws.between + node.value;
            colorStr = colorStr.replace(/\n/g, '');
        }

        result.warn(RULENAME, {
            node: node,
            ruleName: RULENAME,
            line: line,
            col: col,
            message: msg,
            colorMessage: '`' + lineContent.replace(colorStr, _chalk2.default.magenta(colorStr)) + '` ' + _chalk2.default.grey(msg)
        });
        global.CSSHINT_INVALID_ALL_COUNT++;
    }
};

/**
 * 对 atRuleList 的处理，上下文是 atRuleList
 *
 * @param {Array} atRuleList arRule 对象集合
 * @param {Object} result postcss result 对象
 * @param {Object} rule css.walkRules 里的 rule 对象
 * @param {string} indentStr 缩进的字符串
 * @param {number} startPos 开始计算缩进的偏移量，相当于这一行的 column，和 indentStr 没有关系
 */
var atRuleListIterator = function atRuleListIterator(atRuleList, result, rule, indentStr, startPos) {
    // 说明当前这个选择器没有 atRule
    if (!atRuleList.length) {
        var ruleStartCol = rule.source.start.column;
        if (ruleStartCol - 1 !== startPos) {
            addWarn(rule, result, getMsg(rule.raws.before.replace(/\n/g, ''), ''));
        }

        // 选择器中的属性默认的缩进层级为 1
        var indentLevel = 1;
        rule.walkDecls(function (decl) {
            if (!isValidVendorProp(decl, result)) {
                return;
            }

            if (prefixList.indexOf(decl.prop) > -1) {
                return;
            }

            var ruleBefore = rule.raws.before;

            // 加上 \s，是为了防止如下情况
            // div {
            //     color: #fff;
            // }
            // span {
            //     color: #000;
            // }
            // 当 div 的 } 符号后有一个空格的时候，会导致 span 的第一条非注释属性报 block-indent 的错误
            // \s\s\s\n\n\s\s\s 要去掉 \n 前面的 \s，\n 后面的 \s 需要计算为下一行的开头位置，所以不能去掉
            ruleBefore = ruleBefore.replace(/\s*\n+/, '');

            // 正确的缩进字符串
            var shouldIndentStr = ruleBefore;
            for (var j = 0; j < indentLevel; j++) {
                shouldIndentStr += indentStr;
            }

            var declBefore = decl.raws.before;
            // 兼容 background-position-x: 170px;; 属性后有多个分号的情况
            declBefore = declBefore.replace(/^[^\n]*/, '');
            // 把 before 里面的多个空行换成一个，便于之后的计算
            declBefore = declBefore.replace(/\n*/, '\n');

            var length = declBefore.length;
            var hackPrefixChar = declBefore[length - 1];
            if (hackPrefixChar === '_' || hackPrefixChar === '*') {
                shouldIndentStr += hackPrefixChar;
            }

            if (declBefore !== '\n' + shouldIndentStr) {
                addWarn(decl, result, getMsg(declBefore.replace(/\n/g, '').slice(0, -1), shouldIndentStr.slice(0, -1)));
            }
        });
    }

    // 对 atRule 处理
    atRuleList.forEach(function (ar, index) {
        var raws = ar.raws,
            source = ar.source;

        var arBefore = raws.before;
        // 兼容 background-position-x: 170px;; 属性后有多个分号的情况
        arBefore = arBefore.replace(/^[^\n]*/, '');
        // 把 arBefore 里面的多个空行换成一个，便于之后的计算
        arBefore = arBefore.replace(/\n*/, '\n');

        var startCol = source.start.column;

        // 判断第一行，只需要看开头的 col 是否等于 startPos
        if (index === 0) {
            if (startCol - 1 !== startPos) {
                addWarn(ar, result, getMsg(arBefore.replace(/\n/g, ''), ''));
            }
        }
        // 非第一行的 @ 选择器，那么开头就必须有缩进，缩进根据 indentStr 来计算
        else {
                // 正确的缩进字符串
                var shouldIndentStr = '';
                for (var i = 0; i < index; i++) {
                    shouldIndentStr += indentStr;
                }

                if (arBefore !== '\n' + shouldIndentStr) {
                    addWarn(ar, result, getMsg(arBefore.replace(/\n/g, '').slice(0, -1), shouldIndentStr.slice(0, -1)));
                }
            }

        // 最后一个 @ 选择器，在这里处理 atRule 里的 decl 以及 atRule 里的 rule
        if (index === atRuleList.length - 1) {
            var ruleBefore = rule.raws.before;
            // 兼容 background-position-x: 170px;; 属性后有多个分号的情况
            ruleBefore = ruleBefore.replace(/^[^\n]*/, '');
            // 把 ruleBefore 里面的多个空行换成一个，便于之后的计算
            ruleBefore = ruleBefore.replace(/\n*/, '\n');

            // 正确的缩进字符串
            var ruleShouldIndentStr = '';
            for (var q = 0; q <= index; q++) {
                ruleShouldIndentStr += indentStr;
            }

            if (ruleBefore !== '\n' + ruleShouldIndentStr) {
                addWarn(rule, result, getMsg(ruleBefore.replace(/\n/g, '').slice(0, -1), ruleShouldIndentStr.slice(0, -1)));
            }

            // 处理 atRule 里面的 decl，其实这里用 rule.walkDecls 也可以
            ar.walkDecls(function (decl) {
                if (!isValidVendorProp(decl, result)) {
                    return;
                }

                if (prefixList.indexOf(decl.prop) > -1) {
                    return;
                }

                var before = decl.raws.before;
                // 兼容 background-position-x: 170px;; 属性后有多个分号的情况
                before = before.replace(/^[^\n]*/, '');
                // 把 before 里面的多个空行换成一个，便于之后的计算
                before = before.replace(/\n*/, '\n');

                // 正确的缩进字符串
                var shouldIndentStr = '';
                // 属性时 index 要加 1，因为这个 index 是 rule 的 index，而属性和 rule 之间要有一个缩进
                for (var _i = 0; _i <= index + 1; _i++) {
                    shouldIndentStr += indentStr;
                }

                var length = before.length;
                var hackPrefixChar = before[length - 1];
                if (hackPrefixChar === '_' || hackPrefixChar === '*') {
                    shouldIndentStr += hackPrefixChar;
                }

                if (before !== '\n' + shouldIndentStr) {
                    addWarn(decl, result, getMsg(before.replace(/\n/g, '').slice(0, -1), shouldIndentStr.slice(0, -1)));
                }
            });
        }
    });
};

/**
 * 具体的检测逻辑
 *
 * @param {Object} opts 参数
 * @param {*} opts.ruleVal 当前规则具体配置的值
 * @param {string} opts.fileContent 文件内容
 * @param {string} opts.filePath 文件路径
 */
var check = exports.check = _postcss2.default.plugin(RULENAME, function (opts) {
    return function (css, result) {
        if (!Array.isArray(opts.ruleVal)) {
            return;
        }

        lineCache = 0;

        // 缩进的字符串
        var indentStr = opts.ruleVal[0];

        // 开始计算缩进的偏移量，相当于这一行的 column，和 opts.ruleVal[0] 没有关系
        var startPos = opts.ruleVal[1];

        css.walkRules(function (rule) {

            if (global.CSSHINT_INVALID_ALL_COUNT >= opts.maxError) {
                return;
            }

            // 这里用 atRuleList 对 atRule 做一下处理是因为 postcss 默认是从 decl -> atrule -> rule -> root
            // 即从里向外的顺序处理的，但是我们这里需要知道由里向外的层级，我们需要知道层级的开始以及结束点
            // 因此 atRuleList.unshift 这样倒序过来
            var atRuleList = [];
            var parentRule = rule.parent;
            while (parentRule.type === 'atrule') {
                atRuleList.unshift(parentRule);
                parentRule = parentRule.parent;
            }

            atRuleListIterator(atRuleList, result, rule, indentStr, startPos);
        });
    };
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9ydWxlL2Jsb2NrLWluZGVudC5qcyJdLCJuYW1lcyI6WyJwcmVmaXhMaXN0IiwiUlVMRU5BTUUiLCJsaW5lQ2FjaGUiLCJnZXRNc2ciLCJjdXJJbmRlbnRTdHIiLCJuZWVkZWRJbmRlbnRTdHIiLCJsZW5ndGgiLCJpc1ZhbGlkVmVuZG9yUHJvcCIsInByb3AiLCJkZWNsIiwic3RhbmRhcmRQcm9wZXJ0eSIsInJlcGxhY2UiLCJpbmRleE9mIiwiYWRkV2FybiIsIm5vZGUiLCJyZXN1bHQiLCJtc2ciLCJoYWNrUHJlZml4Q2hhciIsInNvdXJjZSIsImxpbmUiLCJzdGFydCIsImNvbCIsImNvbHVtbiIsImxpbmVDb250ZW50IiwiaW5wdXQiLCJjc3MiLCJjb2xvclN0ciIsInNlbGVjdG9yIiwidHlwZSIsInJhd3MiLCJiZXR3ZWVuIiwidmFsdWUiLCJ3YXJuIiwicnVsZU5hbWUiLCJtZXNzYWdlIiwiY29sb3JNZXNzYWdlIiwiY2hhbGsiLCJtYWdlbnRhIiwiZ3JleSIsImdsb2JhbCIsIkNTU0hJTlRfSU5WQUxJRF9BTExfQ09VTlQiLCJhdFJ1bGVMaXN0SXRlcmF0b3IiLCJhdFJ1bGVMaXN0IiwicnVsZSIsImluZGVudFN0ciIsInN0YXJ0UG9zIiwicnVsZVN0YXJ0Q29sIiwiYmVmb3JlIiwiaW5kZW50TGV2ZWwiLCJ3YWxrRGVjbHMiLCJydWxlQmVmb3JlIiwic2hvdWxkSW5kZW50U3RyIiwiaiIsImRlY2xCZWZvcmUiLCJzbGljZSIsImZvckVhY2giLCJhciIsImluZGV4IiwiYXJCZWZvcmUiLCJzdGFydENvbCIsImkiLCJydWxlU2hvdWxkSW5kZW50U3RyIiwicSIsImNoZWNrIiwicG9zdGNzcyIsInBsdWdpbiIsIkFycmF5IiwiaXNBcnJheSIsIm9wdHMiLCJydWxlVmFsIiwid2Fsa1J1bGVzIiwibWF4RXJyb3IiLCJwYXJlbnRSdWxlIiwicGFyZW50IiwidW5zaGlmdCJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQU1BOzs7O0FBQ0E7Ozs7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O0FBQUEsV0FDMUMsVUFBQ3dCLEdBQUQsRUFBTVYsTUFBTixFQUFpQjtBQUNiLFlBQUksQ0FBQ21ELE1BQU1DLE9BQU4sQ0FBY0MsS0FBS0MsT0FBbkIsQ0FBTCxFQUFrQztBQUM5QjtBQUNIOztBQUdEbkUsb0JBQVksQ0FBWjs7QUFFQTtBQUNBLFlBQU0wQyxZQUFZd0IsS0FBS0MsT0FBTCxDQUFhLENBQWIsQ0FBbEI7O0FBRUE7QUFDQSxZQUFNeEIsV0FBV3VCLEtBQUtDLE9BQUwsQ0FBYSxDQUFiLENBQWpCOztBQUVBNUMsWUFBSTZDLFNBQUosQ0FBYyxnQkFBUTs7QUFFbEIsZ0JBQUkvQixPQUFPQyx5QkFBUCxJQUFvQzRCLEtBQUtHLFFBQTdDLEVBQXVEO0FBQ25EO0FBQ0g7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsZ0JBQU03QixhQUFhLEVBQW5CO0FBQ0EsZ0JBQUk4QixhQUFhN0IsS0FBSzhCLE1BQXRCO0FBQ0EsbUJBQU9ELFdBQVc1QyxJQUFYLEtBQW9CLFFBQTNCLEVBQXFDO0FBQ2pDYywyQkFBV2dDLE9BQVgsQ0FBbUJGLFVBQW5CO0FBQ0FBLDZCQUFhQSxXQUFXQyxNQUF4QjtBQUNIOztBQUVEaEMsK0JBQW1CQyxVQUFuQixFQUErQjNCLE1BQS9CLEVBQXVDNEIsSUFBdkMsRUFBNkNDLFNBQTdDLEVBQXdEQyxRQUF4RDtBQUNILFNBakJEO0FBa0JILEtBakN5QztBQUFBLENBQXpCLENBQWQiLCJmaWxlIjoiYmxvY2staW5kZW50LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZSBibG9jay1pbmRlbnQg55qE5qOA5rWL6YC76L6RXG4gKiAgICAgICAwMDI6IFvlvLrliLZdIOS9v+eUqCBgNGAg5Liq56m65qC85YGa5Li65LiA5Liq57yp6L+b5bGC57qn77yM5LiN5YWB6K645L2/55SoIGAyYCDkuKrnqbrmoLwg5oiWIGB0YWJgIOWtl+espuOAglxuICogQGF1dGhvciBpZWxnbmF3KHd1amkwMjIzQGdtYWlsLmNvbSlcbiAqL1xuXG5pbXBvcnQgY2hhbGsgZnJvbSAnY2hhbGsnO1xuaW1wb3J0IHBvc3Rjc3MgZnJvbSAncG9zdGNzcyc7XG5cbmltcG9ydCB7Z2V0TGluZUNvbnRlbnR9IGZyb20gJy4uL3V0aWwnO1xuXG5pbXBvcnQge2dldFByZWZpeExpc3R9IGZyb20gJy4uL3ByZWZpeGVzJztcblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBwcmVmaXhMaXN0ID0gZ2V0UHJlZml4TGlzdCgpO1xuXG4vKipcbiAqIOW9k+WJjeaWh+S7tuaJgOS7o+ihqOeahOinhOWImeWQjeensFxuICpcbiAqIEBjb25zdFxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuY29uc3QgUlVMRU5BTUUgPSAnYmxvY2staW5kZW50JztcblxuLyoqXG4gKiDooYzlj7fnmoTnvJPlrZjvvIzpmLLmraLlkIzkuIDooYzlpJrmrKHmiqXplJlcbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5sZXQgbGluZUNhY2hlID0gMDtcblxuLyoqXG4gKiDojrflj5bplJnor6/kv6Hmga9cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY3VySW5kZW50U3RyIOW9k+WJjeeahOe8qei/m+eahOWtl+espuS4su+8iOmUmeivr+eahO+8iVxuICogQHBhcmFtIHtzdHJpbmd9IG5lZWRlZEluZGVudFN0ciDmnJ/mnJvnmoTnmoTnvKnov5vnmoTlrZfnrKbkuLLvvIjmraPnoa7nmoTvvIlcbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9IOmUmeivr+S/oeaBr1xuICovXG5jb25zdCBnZXRNc2cgPSAoY3VySW5kZW50U3RyLCBuZWVkZWRJbmRlbnRTdHIpID0+XG4gICAgJydcbiAgICAgICAgKyAnQmFkIGluZGVudGF0aW9uLCBFeHBlY3RlZCBgJ1xuICAgICAgICArIChuZWVkZWRJbmRlbnRTdHIubGVuZ3RoKVxuICAgICAgICArICdgIGJ1dCBzYXcgYCdcbiAgICAgICAgKyAoY3VySW5kZW50U3RyLmxlbmd0aClcbiAgICAgICAgKyAnYCc7XG5cbi8qKlxuICog5Yik5pat5piv5ZCm5piv5ZCI5rOV55qE5bim5YmN57yA55qEIGNzcyDlsZ7mgKflkI3np7BcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGVjbCBwb3N0Y3NzIOiKgueCueWvueixoVxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59IOe7k+aenFxuICovXG5jb25zdCBpc1ZhbGlkVmVuZG9yUHJvcCA9IGRlY2wgPT4ge1xuICAgIGNvbnN0IHByb3AgPSBkZWNsLnByb3A7XG4gICAgY29uc3Qgc3RhbmRhcmRQcm9wZXJ0eSA9IHByb3AucmVwbGFjZSgvXlxcLSh3ZWJraXR8bW96fG1zfG8pXFwtL2csICcnKTtcbiAgICAvLyDmoIflh4bmqKHlvI/lnKggcHJlZml4TGlzdCDkuK3vvIzpgqPkuYjlpoLmnpwgcHJvcGVydHlOYW1lIOS4jeWcqCBwcmVmaXhMaXN0IOS4rVxuICAgIC8vIOWNs+i/meS4quWxnuaAp+eUqOmUmeS6hu+8jOS+i+WmgiAtby1hbmltYXRpb25cbiAgICBpZiAocHJlZml4TGlzdC5pbmRleE9mKHN0YW5kYXJkUHJvcGVydHkpID4gLTEpIHtcbiAgICAgICAgaWYgKHByZWZpeExpc3QuaW5kZXhPZihwcm9wKSA8PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiDlr7kgZGVjbCDnmoTlpITnkIZcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gbm9kZSBub2RlIOWvueixoe+8jOWPr+iDveaYryBkZWNsIOS5n+WPr+iDveaYryBydWxlXG4gKiBAcGFyYW0ge09iamVjdH0gcmVzdWx0IHBvc3Rjc3Mg6L2s5o2i55qE57uT5p6c5a+56LGhXG4gKiBAcGFyYW0ge3N0cmluZ30gbXNnIOmUmeivr+S/oeaBr1xuICogQHBhcmFtIHtzdHJpbmd9IGhhY2tQcmVmaXhDaGFyIOWxnuaApyBoYWNrIOeahOWJjee8gO+8jGBfYCDmiJbogIUgYCpgXG4gKi9cbmNvbnN0IGFkZFdhcm4gPSAobm9kZSwgcmVzdWx0LCBtc2csIGhhY2tQcmVmaXhDaGFyKSA9PiB7XG4gICAgY29uc3Qgc291cmNlID0gbm9kZS5zb3VyY2U7XG4gICAgY29uc3QgbGluZSA9IHNvdXJjZS5zdGFydC5saW5lO1xuICAgIGlmIChsaW5lQ2FjaGUgIT09IGxpbmUpIHtcbiAgICAgICAgbGluZUNhY2hlID0gbGluZTtcbiAgICAgICAgY29uc3QgY29sID0gc291cmNlLnN0YXJ0LmNvbHVtbjtcblxuICAgICAgICBjb25zdCBsaW5lQ29udGVudCA9IGdldExpbmVDb250ZW50KGxpbmUsIHNvdXJjZS5pbnB1dC5jc3MpIHx8ICcnO1xuICAgICAgICBsZXQgY29sb3JTdHIgPSAnJztcblxuICAgICAgICBpZiAobm9kZS5zZWxlY3Rvcikge1xuICAgICAgICAgICAgY29sb3JTdHIgPSBub2RlLnNlbGVjdG9yO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gJ2F0cnVsZScpIHtcbiAgICAgICAgICAgIGNvbG9yU3RyID0gbGluZUNvbnRlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb2xvclN0ciA9IChoYWNrUHJlZml4Q2hhciB8fCAnJykgKyBub2RlLnByb3AgKyBub2RlLnJhd3MuYmV0d2VlbiArIG5vZGUudmFsdWU7XG4gICAgICAgICAgICBjb2xvclN0ciA9IGNvbG9yU3RyLnJlcGxhY2UoL1xcbi9nLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQud2FybihSVUxFTkFNRSwge1xuICAgICAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgICAgIHJ1bGVOYW1lOiBSVUxFTkFNRSxcbiAgICAgICAgICAgIGxpbmU6IGxpbmUsXG4gICAgICAgICAgICBjb2w6IGNvbCxcbiAgICAgICAgICAgIG1lc3NhZ2U6IG1zZyxcbiAgICAgICAgICAgIGNvbG9yTWVzc2FnZTogJ2AnXG4gICAgICAgICAgICAgICAgKyBsaW5lQ29udGVudC5yZXBsYWNlKFxuICAgICAgICAgICAgICAgICAgICBjb2xvclN0cixcbiAgICAgICAgICAgICAgICAgICAgY2hhbGsubWFnZW50YShjb2xvclN0cilcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKyAnYCAnXG4gICAgICAgICAgICAgICAgKyBjaGFsay5ncmV5KG1zZylcbiAgICAgICAgfSk7XG4gICAgICAgIGdsb2JhbC5DU1NISU5UX0lOVkFMSURfQUxMX0NPVU5UKys7XG4gICAgfVxufTtcblxuLyoqXG4gKiDlr7kgYXRSdWxlTGlzdCDnmoTlpITnkIbvvIzkuIrkuIvmlofmmK8gYXRSdWxlTGlzdFxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGF0UnVsZUxpc3QgYXJSdWxlIOWvueixoembhuWQiFxuICogQHBhcmFtIHtPYmplY3R9IHJlc3VsdCBwb3N0Y3NzIHJlc3VsdCDlr7nosaFcbiAqIEBwYXJhbSB7T2JqZWN0fSBydWxlIGNzcy53YWxrUnVsZXMg6YeM55qEIHJ1bGUg5a+56LGhXG4gKiBAcGFyYW0ge3N0cmluZ30gaW5kZW50U3RyIOe8qei/m+eahOWtl+espuS4slxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0UG9zIOW8gOWni+iuoeeul+e8qei/m+eahOWBj+enu+mHj++8jOebuOW9k+S6jui/meS4gOihjOeahCBjb2x1bW7vvIzlkowgaW5kZW50U3RyIOayoeacieWFs+ezu1xuICovXG5jb25zdCBhdFJ1bGVMaXN0SXRlcmF0b3IgPSAoYXRSdWxlTGlzdCwgcmVzdWx0LCBydWxlLCBpbmRlbnRTdHIsIHN0YXJ0UG9zKSA9PiB7XG4gICAgLy8g6K+05piO5b2T5YmN6L+Z5Liq6YCJ5oup5Zmo5rKh5pyJIGF0UnVsZVxuICAgIGlmICghYXRSdWxlTGlzdC5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcnVsZVN0YXJ0Q29sID0gcnVsZS5zb3VyY2Uuc3RhcnQuY29sdW1uO1xuICAgICAgICBpZiAocnVsZVN0YXJ0Q29sIC0gMSAhPT0gc3RhcnRQb3MpIHtcbiAgICAgICAgICAgIGFkZFdhcm4ocnVsZSwgcmVzdWx0LCBnZXRNc2cocnVsZS5yYXdzLmJlZm9yZS5yZXBsYWNlKC9cXG4vZywgJycpLCAnJykpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8g6YCJ5oup5Zmo5Lit55qE5bGe5oCn6buY6K6k55qE57yp6L+b5bGC57qn5Li6IDFcbiAgICAgICAgY29uc3QgaW5kZW50TGV2ZWwgPSAxO1xuICAgICAgICBydWxlLndhbGtEZWNscyhkZWNsID0+IHtcbiAgICAgICAgICAgIGlmICghaXNWYWxpZFZlbmRvclByb3AoZGVjbCwgcmVzdWx0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHByZWZpeExpc3QuaW5kZXhPZihkZWNsLnByb3ApID4gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBydWxlQmVmb3JlID0gcnVsZS5yYXdzLmJlZm9yZTtcblxuICAgICAgICAgICAgLy8g5Yqg5LiKIFxcc++8jOaYr+S4uuS6humYsuatouWmguS4i+aDheWGtVxuICAgICAgICAgICAgLy8gZGl2IHtcbiAgICAgICAgICAgIC8vICAgICBjb2xvcjogI2ZmZjtcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIC8vIHNwYW4ge1xuICAgICAgICAgICAgLy8gICAgIGNvbG9yOiAjMDAwO1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgLy8g5b2TIGRpdiDnmoQgfSDnrKblj7flkI7mnInkuIDkuKrnqbrmoLznmoTml7blgJnvvIzkvJrlr7zoh7Qgc3BhbiDnmoTnrKzkuIDmnaHpnZ7ms6jph4rlsZ7mgKfmiqUgYmxvY2staW5kZW50IOeahOmUmeivr1xuICAgICAgICAgICAgLy8gXFxzXFxzXFxzXFxuXFxuXFxzXFxzXFxzIOimgeWOu+aOiSBcXG4g5YmN6Z2i55qEIFxcc++8jFxcbiDlkI7pnaLnmoQgXFxzIOmcgOimgeiuoeeul+S4uuS4i+S4gOihjOeahOW8gOWktOS9jee9ru+8jOaJgOS7peS4jeiDveWOu+aOiVxuICAgICAgICAgICAgcnVsZUJlZm9yZSA9IHJ1bGVCZWZvcmUucmVwbGFjZSgvXFxzKlxcbisvLCAnJyk7XG5cbiAgICAgICAgICAgIC8vIOato+ehrueahOe8qei/m+Wtl+espuS4slxuICAgICAgICAgICAgbGV0IHNob3VsZEluZGVudFN0ciA9IHJ1bGVCZWZvcmU7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGluZGVudExldmVsOyBqKyspIHtcbiAgICAgICAgICAgICAgICBzaG91bGRJbmRlbnRTdHIgKz0gaW5kZW50U3RyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgZGVjbEJlZm9yZSA9IGRlY2wucmF3cy5iZWZvcmU7XG4gICAgICAgICAgICAvLyDlhbzlrrkgYmFja2dyb3VuZC1wb3NpdGlvbi14OiAxNzBweDs7IOWxnuaAp+WQjuacieWkmuS4quWIhuWPt+eahOaDheWGtVxuICAgICAgICAgICAgZGVjbEJlZm9yZSA9IGRlY2xCZWZvcmUucmVwbGFjZSgvXlteXFxuXSovLCAnJyk7XG4gICAgICAgICAgICAvLyDmioogYmVmb3JlIOmHjOmdoueahOWkmuS4quepuuihjOaNouaIkOS4gOS4qu+8jOS+v+S6juS5i+WQjueahOiuoeeul1xuICAgICAgICAgICAgZGVjbEJlZm9yZSA9IGRlY2xCZWZvcmUucmVwbGFjZSgvXFxuKi8sICdcXG4nKTtcblxuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gZGVjbEJlZm9yZS5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBoYWNrUHJlZml4Q2hhciA9IGRlY2xCZWZvcmVbbGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBpZiAoaGFja1ByZWZpeENoYXIgPT09ICdfJyB8fCBoYWNrUHJlZml4Q2hhciA9PT0gJyonKSB7XG4gICAgICAgICAgICAgICAgc2hvdWxkSW5kZW50U3RyICs9IGhhY2tQcmVmaXhDaGFyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGVjbEJlZm9yZSAhPT0gJ1xcbicgKyBzaG91bGRJbmRlbnRTdHIpIHtcbiAgICAgICAgICAgICAgICBhZGRXYXJuKGRlY2wsIHJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgZ2V0TXNnKGRlY2xCZWZvcmUucmVwbGFjZSgvXFxuL2csICcnKS5zbGljZSgwLCAtMSksIHNob3VsZEluZGVudFN0ci5zbGljZSgwLCAtMSkpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8g5a+5IGF0UnVsZSDlpITnkIZcbiAgICBhdFJ1bGVMaXN0LmZvckVhY2goKGFyLCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCB7cmF3cywgc291cmNlfSA9IGFyO1xuICAgICAgICBsZXQgYXJCZWZvcmUgPSByYXdzLmJlZm9yZTtcbiAgICAgICAgLy8g5YW85a65IGJhY2tncm91bmQtcG9zaXRpb24teDogMTcwcHg7OyDlsZ7mgKflkI7mnInlpJrkuKrliIblj7fnmoTmg4XlhrVcbiAgICAgICAgYXJCZWZvcmUgPSBhckJlZm9yZS5yZXBsYWNlKC9eW15cXG5dKi8sICcnKTtcbiAgICAgICAgLy8g5oqKIGFyQmVmb3JlIOmHjOmdoueahOWkmuS4quepuuihjOaNouaIkOS4gOS4qu+8jOS+v+S6juS5i+WQjueahOiuoeeul1xuICAgICAgICBhckJlZm9yZSA9IGFyQmVmb3JlLnJlcGxhY2UoL1xcbiovLCAnXFxuJyk7XG5cbiAgICAgICAgY29uc3Qgc3RhcnRDb2wgPSBzb3VyY2Uuc3RhcnQuY29sdW1uO1xuXG4gICAgICAgIC8vIOWIpOaWreesrOS4gOihjO+8jOWPqumcgOimgeeci+W8gOWktOeahCBjb2wg5piv5ZCm562J5LqOIHN0YXJ0UG9zXG4gICAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKHN0YXJ0Q29sIC0gMSAhPT0gc3RhcnRQb3MpIHtcbiAgICAgICAgICAgICAgICBhZGRXYXJuKGFyLCByZXN1bHQsIGdldE1zZyhhckJlZm9yZS5yZXBsYWNlKC9cXG4vZywgJycpLCAnJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIOmdnuesrOS4gOihjOeahCBAIOmAieaLqeWZqO+8jOmCo+S5iOW8gOWktOWwseW/hemhu+aciee8qei/m++8jOe8qei/m+agueaNriBpbmRlbnRTdHIg5p2l6K6h566XXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8g5q2j56Gu55qE57yp6L+b5a2X56ym5LiyXG4gICAgICAgICAgICBsZXQgc2hvdWxkSW5kZW50U3RyID0gJyc7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGV4OyBpKyspIHtcbiAgICAgICAgICAgICAgICBzaG91bGRJbmRlbnRTdHIgKz0gaW5kZW50U3RyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYXJCZWZvcmUgIT09ICdcXG4nICsgc2hvdWxkSW5kZW50U3RyKSB7XG4gICAgICAgICAgICAgICAgYWRkV2FybihhciwgcmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICBnZXRNc2coYXJCZWZvcmUucmVwbGFjZSgvXFxuL2csICcnKS5zbGljZSgwLCAtMSksIHNob3VsZEluZGVudFN0ci5zbGljZSgwLCAtMSkpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIOacgOWQjuS4gOS4qiBAIOmAieaLqeWZqO+8jOWcqOi/memHjOWkhOeQhiBhdFJ1bGUg6YeM55qEIGRlY2wg5Lul5Y+KIGF0UnVsZSDph4znmoQgcnVsZVxuICAgICAgICBpZiAoaW5kZXggPT09IGF0UnVsZUxpc3QubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgbGV0IHJ1bGVCZWZvcmUgPSBydWxlLnJhd3MuYmVmb3JlO1xuICAgICAgICAgICAgLy8g5YW85a65IGJhY2tncm91bmQtcG9zaXRpb24teDogMTcwcHg7OyDlsZ7mgKflkI7mnInlpJrkuKrliIblj7fnmoTmg4XlhrVcbiAgICAgICAgICAgIHJ1bGVCZWZvcmUgPSBydWxlQmVmb3JlLnJlcGxhY2UoL15bXlxcbl0qLywgJycpO1xuICAgICAgICAgICAgLy8g5oqKIHJ1bGVCZWZvcmUg6YeM6Z2i55qE5aSa5Liq56m66KGM5o2i5oiQ5LiA5Liq77yM5L6/5LqO5LmL5ZCO55qE6K6h566XXG4gICAgICAgICAgICBydWxlQmVmb3JlID0gcnVsZUJlZm9yZS5yZXBsYWNlKC9cXG4qLywgJ1xcbicpO1xuXG4gICAgICAgICAgICAvLyDmraPnoa7nmoTnvKnov5vlrZfnrKbkuLJcbiAgICAgICAgICAgIGxldCBydWxlU2hvdWxkSW5kZW50U3RyID0gJyc7XG4gICAgICAgICAgICBmb3IgKGxldCBxID0gMDsgcSA8PSBpbmRleDsgcSsrKSB7XG4gICAgICAgICAgICAgICAgcnVsZVNob3VsZEluZGVudFN0ciArPSBpbmRlbnRTdHI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChydWxlQmVmb3JlICE9PSAnXFxuJyArIHJ1bGVTaG91bGRJbmRlbnRTdHIpIHtcbiAgICAgICAgICAgICAgICBhZGRXYXJuKHJ1bGUsIHJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgZ2V0TXNnKHJ1bGVCZWZvcmUucmVwbGFjZSgvXFxuL2csICcnKS5zbGljZSgwLCAtMSksIHJ1bGVTaG91bGRJbmRlbnRTdHIuc2xpY2UoMCwgLTEpKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIOWkhOeQhiBhdFJ1bGUg6YeM6Z2i55qEIGRlY2zvvIzlhbblrp7ov5nph4znlKggcnVsZS53YWxrRGVjbHMg5Lmf5Y+v5LulXG4gICAgICAgICAgICBhci53YWxrRGVjbHMoZGVjbCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkVmVuZG9yUHJvcChkZWNsLCByZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocHJlZml4TGlzdC5pbmRleE9mKGRlY2wucHJvcCkgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGV0IGJlZm9yZSA9IGRlY2wucmF3cy5iZWZvcmU7XG4gICAgICAgICAgICAgICAgLy8g5YW85a65IGJhY2tncm91bmQtcG9zaXRpb24teDogMTcwcHg7OyDlsZ7mgKflkI7mnInlpJrkuKrliIblj7fnmoTmg4XlhrVcbiAgICAgICAgICAgICAgICBiZWZvcmUgPSBiZWZvcmUucmVwbGFjZSgvXlteXFxuXSovLCAnJyk7XG4gICAgICAgICAgICAgICAgLy8g5oqKIGJlZm9yZSDph4zpnaLnmoTlpJrkuKrnqbrooYzmjaLmiJDkuIDkuKrvvIzkvr/kuo7kuYvlkI7nmoTorqHnrpdcbiAgICAgICAgICAgICAgICBiZWZvcmUgPSBiZWZvcmUucmVwbGFjZSgvXFxuKi8sICdcXG4nKTtcblxuICAgICAgICAgICAgICAgIC8vIOato+ehrueahOe8qei/m+Wtl+espuS4slxuICAgICAgICAgICAgICAgIGxldCBzaG91bGRJbmRlbnRTdHIgPSAnJztcbiAgICAgICAgICAgICAgICAvLyDlsZ7mgKfml7YgaW5kZXgg6KaB5YqgIDHvvIzlm6DkuLrov5nkuKogaW5kZXgg5pivIHJ1bGUg55qEIGluZGV477yM6ICM5bGe5oCn5ZKMIHJ1bGUg5LmL6Ze06KaB5pyJ5LiA5Liq57yp6L+bXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gaW5kZXggKyAxOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkSW5kZW50U3RyICs9IGluZGVudFN0cjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGggPSBiZWZvcmUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhY2tQcmVmaXhDaGFyID0gYmVmb3JlW2xlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmIChoYWNrUHJlZml4Q2hhciA9PT0gJ18nIHx8IGhhY2tQcmVmaXhDaGFyID09PSAnKicpIHtcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkSW5kZW50U3RyICs9IGhhY2tQcmVmaXhDaGFyO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChiZWZvcmUgIT09ICdcXG4nICsgc2hvdWxkSW5kZW50U3RyKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZFdhcm4oZGVjbCwgcmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0TXNnKGJlZm9yZS5yZXBsYWNlKC9cXG4vZywgJycpLnNsaWNlKDAsIC0xKSwgc2hvdWxkSW5kZW50U3RyLnNsaWNlKDAsIC0xKSlcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxuXG4vKipcbiAqIOWFt+S9k+eahOajgOa1i+mAu+i+kVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIOWPguaVsFxuICogQHBhcmFtIHsqfSBvcHRzLnJ1bGVWYWwg5b2T5YmN6KeE5YiZ5YW35L2T6YWN572u55qE5YC8XG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5maWxlQ29udGVudCDmlofku7blhoXlrrlcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLmZpbGVQYXRoIOaWh+S7tui3r+W+hFxuICovXG5leHBvcnQgY29uc3QgY2hlY2sgPSBwb3N0Y3NzLnBsdWdpbihSVUxFTkFNRSwgb3B0cyA9PlxuICAgIChjc3MsIHJlc3VsdCkgPT4ge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob3B0cy5ydWxlVmFsKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cblxuICAgICAgICBsaW5lQ2FjaGUgPSAwO1xuXG4gICAgICAgIC8vIOe8qei/m+eahOWtl+espuS4slxuICAgICAgICBjb25zdCBpbmRlbnRTdHIgPSBvcHRzLnJ1bGVWYWxbMF07XG5cbiAgICAgICAgLy8g5byA5aeL6K6h566X57yp6L+b55qE5YGP56e76YeP77yM55u45b2T5LqO6L+Z5LiA6KGM55qEIGNvbHVtbu+8jOWSjCBvcHRzLnJ1bGVWYWxbMF0g5rKh5pyJ5YWz57O7XG4gICAgICAgIGNvbnN0IHN0YXJ0UG9zID0gb3B0cy5ydWxlVmFsWzFdO1xuXG4gICAgICAgIGNzcy53YWxrUnVsZXMocnVsZSA9PiB7XG5cbiAgICAgICAgICAgIGlmIChnbG9iYWwuQ1NTSElOVF9JTlZBTElEX0FMTF9DT1VOVCA+PSBvcHRzLm1heEVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyDov5nph4znlKggYXRSdWxlTGlzdCDlr7kgYXRSdWxlIOWBmuS4gOS4i+WkhOeQhuaYr+WboOS4uiBwb3N0Y3NzIOm7mOiupOaYr+S7jiBkZWNsIC0+IGF0cnVsZSAtPiBydWxlIC0+IHJvb3RcbiAgICAgICAgICAgIC8vIOWNs+S7jumHjOWQkeWklueahOmhuuW6j+WkhOeQhueahO+8jOS9huaYr+aIkeS7rOi/memHjOmcgOimgeefpemBk+eUsemHjOWQkeWklueahOWxgue6p++8jOaIkeS7rOmcgOimgeefpemBk+Wxgue6p+eahOW8gOWni+S7peWPiue7k+adn+eCuVxuICAgICAgICAgICAgLy8g5Zug5q2kIGF0UnVsZUxpc3QudW5zaGlmdCDov5nmoLflgJLluo/ov4fmnaVcbiAgICAgICAgICAgIGNvbnN0IGF0UnVsZUxpc3QgPSBbXTtcbiAgICAgICAgICAgIGxldCBwYXJlbnRSdWxlID0gcnVsZS5wYXJlbnQ7XG4gICAgICAgICAgICB3aGlsZSAocGFyZW50UnVsZS50eXBlID09PSAnYXRydWxlJykge1xuICAgICAgICAgICAgICAgIGF0UnVsZUxpc3QudW5zaGlmdChwYXJlbnRSdWxlKTtcbiAgICAgICAgICAgICAgICBwYXJlbnRSdWxlID0gcGFyZW50UnVsZS5wYXJlbnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGF0UnVsZUxpc3RJdGVyYXRvcihhdFJ1bGVMaXN0LCByZXN1bHQsIHJ1bGUsIGluZGVudFN0ciwgc3RhcnRQb3MpO1xuICAgICAgICB9KTtcbiAgICB9XG4pO1xuIl19